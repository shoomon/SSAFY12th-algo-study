# 데이터베이스



데이터베이스란, 여러 사람이 공유하여 사용할 목적으로 일정한 규칙 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음이다.



## 데이터베이스의 기본

### DBMS

DBMS(Database Management System) : 데이터베이스에 접근하여 정의, 조작, 제어 등을 지원하는 소프트웨어이다. 데이터 작업을 수행할 뿐만 아니라 데이터베이스를 보호하고 보안을 제공한다.  




DBMS의 유형은 계층형(Hierarchical), 망형(Network), 관계형(Relational), 객체지향형(Object-Oriented), 객체관계형(Object-Relational), NoSQL 등으로 분류된다. 현재 사용되는 DBMS 중에는 관계형 DBMS가 가장 많은 부분을 차지하며, MySQL도 관계형 DBMS에 포함된다.  


### 기능

- 중복 제어: 동일한 데이터가 여러 위치에 중복 저장되는 현상을 방지한다. 데이터가 중복되면, 저장 공간이 낭비되고 데이터의 일관성이 깨질 수 있다.
- 접근 통제: DBMS는 사용자마다 다양한 권한을 부여할 수 있으며, 권한에 따라 데이터에 대한 접근을 제어할 수 있다.
- 인터페이스 제공 : DBMS는 사용자에게 [SQL](https://namu.wiki/w/SQL) 및 [CLI](https://namu.wiki/w/CLI), [GUI](https://namu.wiki/w/GUI) 등 다양한 인터페이스를 제공한다.
- 관계 표현: 서로 다른 데이터간의 다양한 관계를 표현할 수 있는 기능을 제공한다.
  - 샤딩/파티셔닝: 구조 최적화를 위해 작은 단위로 쪼개는 기능을 제공한다.
- 무결성 제약 조건: 무결성에 관한 제약 조건을 정의/검사하는 기능을 제공한다. 데이터베이스는 반드시 무결성 제약조건을 통과한 데이터만을 저장하고 있어야 한다.
- 백업 기능 지원



사용자들이은 응용프로그램을 통해 DBMS에 접근하며, DBMS를 통해 데이터베이스를 제어 할 수 있다. 



---

### SQL



SQL(Structured Query Language)은 관계형 데이터베이스에서 사용되는 언어로, **‘에스큐엘’** 또는 **‘시퀄’**로 읽는다. SQL이 데이터베이스를 조작하는 ‘언어’이긴 하지만 일반적인 프로그래밍 언어(C, 자바, 파이썬 등)와는 조금 다른 특성을 갖는다.

 SQL은 DB 벤더(DB를 만드는 회사 ex) oracle, mysql, postgresql )사 마다 조금씩 다른 경우가 있으며, 특별한 경우가 아닌 한 ANSI 표준을 따른다



---

### 엔티티(Entity)

엔티티 : 개체     


엔티티 : 사람, 장소, 물건, 사건, 개념 등 여러개의 속성을 지닌 명사를 의미한다  


엔티티는 인간의 개념 또는 정보의 세계에서 의미있는 하나의 정보 단위이다. 사물의 본질적인 성질을 속성(attribute) 이라고 하며, 관련있는 속성들이 모여서 의미있는 하나의 정보 단위를 이룬 것이 바로 개체에 해당한다. 파일시스템이나 데이터베이스에서의 레코드(한 행, row)가 개체에 해당한다. 개체들 사이의 연관성을 관계라고 하며, 개체와 관계를 나타낸 모델을 개체-관계 (E-R, Entity Realation)모델라고 한다.

여기서 속성은, 회원(Member) 라는 엔티티가 있다면 이름(name), 이메일(email), 주소(address), 전화번호(phoneNumber)라는 속성을 정의할 수 있다. 이보다 많은 속성이 있찌만 서비스의 요구사항에 맞춰 속성이 정해진다. 



### 약한 엔티티와 강한 엔티티

엔티티 A가 혼자서는 존재하지 못하고 엔티티 B에 종속적이며 B가 존재해야 존재할 수 있다면 A는 약한 엔티티이며 B는 강한 엔티티라고 할 수 있다.



---

### 릴레이션(realation)

테이터베이스에서 정보를 구분하며 저장하는 기본 단위이다. 릴레이션은 관계형 데이터베이스에서는 `테이블(table)` 이라고 하며, 엔티티 하나에 릴레이션 1개(테이블)을 보통 담아 관리한다. 

<img src ="https://blog.kakaocdn.net/dn/che2VL/btrR3ds9dVX/zPZczeHMTuqkiaikhEHwLK/img.png" width=800 height=350>

1. 튜플(행, tuple) : 릴레이션을 구성하는 각각의 행
   * 카디날리티= 튜플의 수
     * (1) 튜플은 릴레이션을 구성하는 각각의 행을 말한다.
     * (2) 튜플은 속성의 모임으로 구성 된다.
     * (3) 파일 구조에서 레코드와 같은 의미이다.
     * (4) 튜플의 수를 카디널리티 또는 기수, 대응수라고 한다.

 

2. 애트리뷰트(속성, attribute) : 데이터베이스를 구성하는 가장 작은 논리적 단위
   * 차수 = 애트리뷰트의 수
     * (1) 속성은 데이터베이스를 구성하는 가장 작은 논리적 단위이다.
     * (2) 파일 구조상의 데이터 항목 또는 데이터 필드에 해당된다.
     * (3) 속성은 개체의 특성을 기술한다.
     * (4) 속성의 수를 디그리 또는 차수라고 한다.

 

3. 도메인 : 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자값들의 집합
   * (1) 도메인은 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자값들의 집합이다.
   * (2) 도메인은 실제 애트리뷰트 값이 나타날 때 그 값의 합법 여부를 시스템이 검사하는데 이용된다. 

 



### 테이블과 컬렉션



데이터베이스의 종류는 크게 관계형 데이터베이스와 NoSQL 데이터베이스로 나눌 수 있다. 
NoSQL : (NonSQl, 또는 Non reaultional) : 전통적인 RDB(관계형데이터베이스) 보다 덜 제한적인 일관성 모델을 이용하는 데이터의 저장 및 검색을 위한 DBMS. 대표적으로 Redis, Mongo DB가 있다.

NoSQL 데이터베이스는 크게 4가지 모델로 나눌 수 있다.

- Key-value - 키 값 저장소. 키는 값에 접근하기 위한 용도로 사용되며 값은 어떠한 형태의 데이터라도 담을 수 있다 
  - 대표적 : Redis
- Document - 데이터는 키와 도큐먼트(Docuemnt 문서)형태로 저장된다. 값(value)가 계층적인 형태로 저장된다. 
  - 대표적 : Mongo db
- Column-family : Row(키 값)와 Column-family, Column-name을 가진다. 연관된 데이터들은 같은 Column-family 안에 속해 있으며, 각자의 Column-name을 가진다. 관계형 모델로 설명하자면 어트리뷰트가 계층적인 구조를 가지고 있는 셈이다. 이렇게 저장된 데이터는 하나의 커다란 테이블로 표현이 가능하며, 질의는 Row, Column-family, Column-name을 통해 수행된다.
  - 대표적 : Cassandra
- Graph :  데이터는 연속적인 노드, 관계, 특성의 형태인 그래프 형태로 저장된다. 그래프 모델에서의 질의는 그래프 순회를 통해 이루어진다.
  - 대표적: Neo4j



MySQL는 레코드(행) - 테이블(행 x 열) - 데이터베이스 (스키마)로 이루어져 있고, MongoDb는 도큐먼트-컬렉션-데이터베이스로 이루어져 있다.

* document란 문서란 뜻이며 json 유사 형식의 문서로 데이터를 저장 및 쿼리할 수 있다. 

---

### 속성(attribute)

속성은 릴레이션에서 관리하는 구체적이며 `고유한 이름을 갖는 정보`이다. 엔티티가 될 수 있는 사물의 여러 속성(이름, 이메일, 전화번호 등)중에서 서비스의, 요구사항을 기반으로 관리해야 할 필요가 있는 속성들만 엔티티의 속성이 된다. 

---

### 도메인(domain)

도메인이란 릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합을 말한다.(데이터 타입이랑 비슷하다고 보면 된다). 성별이라는 속성이 있다면 이 속성이 가질 수 있는 값은 (남, 여)라는 집합이 된다. 



---

### 필드와 레코드

<img src ="https://blog.kakaocdn.net/dn/che2VL/btrR3ds9dVX/zPZczeHMTuqkiaikhEHwLK/img.png" width=800 height=350>

* 엔티티 : EMPLOYEE 테이블
* 속성 : 열 (EMPNO, EMPNAME, TITLE, DNO, SALARY)

* 레코드 : 행(row). 여기서는 2106, 김창섭, 대리, 2 , 200000 라는 1개의 가로 행이 1레코드이다.



#### 책 엔티티 (Book Entity)

속성 : 제목, 가격, ISBN, 저자, 출판년도, 장르, 생성일시, 업데이트일시

| id   | title  | author_id | publishing_year | genre | created_at | updated_at |
| ---- | ------ | --------- | --------------- | ----- | ---------- | ---------- |
| 1    | 책제목 | 123       | 2020/09/01      | 액션  | 2020/05/01 | 2020/09/01 |

* 보통 속성을 컬럼으로 사용하며 영어 이름이 매핑해서 사용하고, 속성에 타입을 지정한다





##### MYSQL 기준 테이블 생성 쿼리

```mysql
CREATE TABLE book (
	id INT NOT NULL AUTO_INCREMENT,
  title VARCHAR(255),
  author_id INT
  publishing_year	VARCHAR(255),
  genre VARCHAR(255),
  created_at DATETITME,
  updated_at DATETTIME,
	PRIMARY KEY (id)
)
```



##### PostgreSQL 테이블 생성 쿼리

```postgresql
CREATE TABLE book (
	id SERIAL PRIMARY KEY,
  title VARCHAR(255),
  author_id INTEGER
  publishing_year	VARCHAR(255),
  genre VARCHAR(255),
  created_at DATETITME,
  updated_at DATETTIME,
)
```

* PostgreSQL에서는 auto increment가 지원이 되는 Sequence 라는 타입을 지원하고 있다.

| 형식        | 크기     | 범위                  | 별칭    |
| ----------- | -------- | --------------------- | ------- |
| smallserial | 2 바이트 | 1~32767               | serial2 |
| serial      | 4 바이트 | 1~2147483647          | serial4 |
| bigserial   | 8 바이트 | 1~9223372036854775807 | serial8 |



#### oracle 테이블 생성 쿼리

```sql
CREATE TABLE book (
	id NUMBER(10) PRIMARY KEY,
  title VARCHAR(255),
  author_id INT
  publishing_year	VARCHAR(255),
  genre VARCHAR(255),
  created_at DATETITME,
  updated_at DATETTIME,
)

// 시퀀스 생성
CREATE SEQUENCE book_seq START WITH 1 INCREMENT BY 1 MAXVALUE 100 CYCLE NOCACHE;

//시퀀스를 사용한 값 삽입
INSERT INTO book values(book_seq.NEXTVAL, 'tmptmp', ...);
```



---

## 필드(속성 )타입

### 숫자형 데이터 타입



* MySQL 

| 데이터 형식                  | 크기        | 숫자 범위              | 설명                                                         |
| ---------------------------- | ----------- | ---------------------- | ------------------------------------------------------------ |
| `bit(n)`                     | N/8         |                        | 1~64Bit 표현, b'0000'형식으로 표현                           |
| `tinyint`                    | 1 바이트    | -128 ~ 127             | 정수                                                         |
| `smallint`                   | 2 바이트    | -32,768 ~ 32,767       | 정수                                                         |
| `mediumint`                  | 3 바이트    | -8,388,608 ~ 8,388,607 | 정수                                                         |
| `int(integer`                | 4 바이트    | 약-21억 ~ +21억        | 정수                                                         |
| `bigint`                     | 8 바이트    | 약 -900경 ~ +900경     | 정수                                                         |
| `float`                      | 4 바이트    | -3.40E+38 ~ -1.17E-38  | 소수점 아래 7자리까지 표현                                   |
| `double real`                | 8 바이트    | -1.22E-308 ~ 1.79E+308 | 소수점 아래 15자리까지 표현                                  |
| DECIMAL(m,[d]) NUMBER(m,[d]) | 5~17 바이트 | -10^38+1 ~ 10^38-1     | 전체 자릿수(m)와 소수점 이하 자릿수(d)를 가진 숫자형 예) decimal(5,2)는 전체 자릿수를 5자리로 하되, 그 중 소수점 이하를 2자리로 하겠다. |



* postgrelsql

| 이름               | 크기     | 설명                        | 범위                                                    |
| ------------------ | -------- | --------------------------- | ------------------------------------------------------- |
| `smallint`         | 2 바이트 | small-range integer         | -32768에서 +32767                                       |
| `integer`          | 4 바이트 | 정수에 대한 일반적인 선택   | -2147483648에서 +2147483647                             |
| `bigint`           | 8 바이트 | large-range integer         | -9223372036854775808 ~ +9223372036854775807             |
| `decimal`          | variable | 정확한 사용자 지정 정밀도   | 소수점 앞 최대 131072 자리; 소수점 이후 최대 16383 자리 |
| `numeric`          | variable | 정확한 사용자 지정 정밀도   | 소수점 앞 최대 131072 자리; 소수점 이후 최대 16383 자리 |
| `real`             | 4 바이트 | variable-precision, inexact | 6 자리 소수 자릿수                                      |
| `double precision` | 8 바이트 | variable-precision, inexact | 십진수 15 자리 정밀도                                   |
| `smallserial`      | 2 바이트 | 작은 자동 증가 정수         | 1 to 32767                                              |
| `serial`           | 4 바이트 | autoincrementing integer    | 1 to 2147483647                                         |
| `bigserial`        | 8 바이트 | 큰 자동 증가 정수           | 1 to 9223372036854775807                                |



### 날짜형 데이터 타입

* mysql

| 자료형      | 크기     | 범위                                                         | 특징                                                        |
| ----------- | -------- | ------------------------------------------------------------ | ----------------------------------------------------------- |
| `date`      | 3 바이트 | ◼ 날짜를 저장할 수 있는 타입. → 1000-01-01 ~ 9999-12-31      | 입력받은 데이터가 유효한 날짜와 시간이 아니면 0을 저장한다. |
| `datetime`  | 8바이트  | ◼ 날짜와 시간을 모두 저장할 수 있는 타입. <br />◼ 데이터값을 입력을 해주어야만 날짜가 입력된다. → 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 |                                                             |
| `timestamp` | 4바이트  | ◼ 날짜와 시간을 모두 저장할 수 있는 타입. <br />◼ 데이터값을 입력해 주지 않고 저장하면 자동으로 현재 날짜가 입력된다.<br /> ◼ 데이터의 최종 변경 시각을 저장하고 확인하는 데 유용하다. → 1970-01-01 00:00:01 ~ 2038-01-19 03:14:07 UTC까지 |                                                             |
| `time`      | 3바이트  | ◼ 시간을 저장할 수 있는 타입. <br />◼ 범위를 초과하면 지정된 범위로 자동 변환되어 저장한다. <br />◼ 유효하지 않은 시간은 '00:00:00'으로 저장한다. → -838:59:59 ~ 838:59:59 |                                                             |
| `year`      | 1바이트  | ◼ 연도를 저장할 수 있는 타입. → 1901 ~ 2155 → 2자리 포맷: 70 ~ 00(1970~2000), 01 ~ 69(2001~2069) → 4자리 포맷: 1901 ~ 2155 | DEFAULT로 4자리 사용.                                       |





* postgresql

| 형식                                  | 크기      | 설명                         | 별칭        |
| ------------------------------------- | --------- | ---------------------------- | ----------- |
| `timestamp` [(p)] [without time zone] | 8 바이트  | 날짜와 시간 모두             |             |
| `timestamp` [(p)] [with time zone]    | 8 바이트  | 날짜와 시간 모두 시간대 포함 | timestamptz |
| `interval` [(p)]                      | 12 바이트 | 시간 간격                    |             |
| `date`                                | 4 바이트  | 날짜                         |             |
| `time` [(p)] [without time zone]      | 8 바이트  | 시간                         |             |
| `time`[(p)] with time zone            | 12 바이트 | 시간, 시간대 첨부            | timetz      |



### 문자형 데이터 타입

* mysql

| **데이터 유형** | 크기                   | **정의**                                                     |
| --------------- | ---------------------- | ------------------------------------------------------------ |
| `CHAR(n)`       | 최대 255byte           | 고정 길이 데이터 타입. <br />지정된 길이보다 짦은 데이터 입력될 시 나머지 공간 공백으로 채워진다. |
| `VARCHAR(n)`    | 최대 65535 바이트      | 가변 길이 데이터 타입. <br /> 지정된 길이보다 짦은 데이터 입력될 시 나머지 공간은 채우지 않는다. |
| `TINYTEXT(n)`   | 최대 255 바이트        | 문자열 데이터 타입                                           |
| `TEXT(n)`       | 최대 65535 바이트      | 문자열 데이터 타입                                           |
| `MEDIUMTEXT(n)` | 최대 16777215 바이트   | 문자열 데이터 타입                                           |
| `LONGTEXT(n)`   | 최대 4294967295 바이트 | 문자열 데이터 타입                                           |



* postgresql

| 형식                   | 크기               | 별칭       |
| ---------------------- | ------------------ | ---------- |
| `character varying(n)` | 가변 길이 문자열   | varchar(n) |
| `character(n)`         | 고정 길이 문자열   | char(n)    |
| `text`                 | 제한없이 가변 길이 |            |



#### Text or Blob

* TEXT: 큰 문자열 저장에 쓰며 주로 게시판의 본문을 저장할 때 사용
* BLOB : 이미지 동영상 든 큰 데이터 저장에 사용. 그러나 보통은 S3같은 클라우드 스토리지 서비스에 올리고 파일 경로를 VARCHAR로 저장 

### ENUM & SET

* ENUM : 최대 65,535개의 요소들을 넣을 수 있다.
* SET : ENUM과 비슷하지만 여러 개의 데이터를 선택할 수 있꼬, 최대 64개의 요소를 넣을 수 있다.



ENUM이나 SET을 쓸 경우 애플리케이션의 수정에 따라 DB에서 정의한 ENUM과 SET 목록을 수정해야 하는 단점이 있다.



### 관계

데이터베이스에 존재하는 여러 테이블끼리는 서로 관계가 있다.  

* 1:1 관계 - 한 레코드와 다른 테이블의 한 레코드가 연결된 경우 
* 1:N 관계 - 한 테이블의 한 레코드와 다른 테이블의 여러 레코드가 연결된 경우
* N:M 관계 - 한 테이블의 여러 레코드와 다른 테이블의 여러 레코드가 연결된 경우 
* 번외로, 스스로를 참조할 수도 있다 - self referencing 

이러한 관계는 화살표로 나타낼 수 있다.

<img src ="https://blog.kakaocdn.net/dn/dLVAGo/btrR30NGBb7/ihxDRAJk3qXNECG14XTXm0/img.png" width=600 height=500>



#### 1:1 관계 - 한 레코드와 다른 테이블의 한 레코드가 연결된 경우 

1:1 관계는 한 테이블을 두 개의 테이블로 나누 테이블의 구조를 더 이해하기 쉽게 만들어 준다.  



#### 1:N 관계 - 한 테이블의 한 레코드와 다른 테이블의 여러 레코드가 연결된 경우

쇼핑몰을 예로 들면, 한 유저가 여러개의 상품을 구매한다면 1:N 으로 관계를 맺을 수 있다.  

하나도 구매하지 않는 상황도 있을 수 있으므로 0도 포함되는 화살표를 통해 표현해야 한다



#### N:M 관계 - 한 테이블의 여러 레코드와 다른 테이블의 여러 레코드가 연결된 경우 

**`N:N(다대다) 관계`**를 위해 스키마를 디자인할 때에는, **Join 테이블**을 만들어 관리한다.
1:N(일대다) 관계와 비슷하지만, 양방향에서 다수의 레코드를 가질 수 있다.

서로의 **`PK`를 자신의 외래키 컬럼**으로 갖고 있어야 한다.
일반적으로, **`N:M`**관계는 **두 테이블의 대표키를 컬럼으로 갖는 또다른 테이블을 생성해서 관리**한다(**조인 테이블**).



---

### 키 (Key)

테이블 간의 관계를 명확하게 하고, 테이블의 인덱스를 위해 설정된 테이블의 구성요소이다.

* 기본키
* 외래키
* 후보키
* 슈퍼키
* 대체키

<img src ="https://blog.kakaocdn.net/dn/bkDhIb/btrR1p2r39p/LxIBgHBhKusGrDQu9JTem0/img.png" width=500 height=350>

  


- **슈퍼 키(Super Key)**: `유일성 만족, 최소성 X` 1개부터 여러개가 될 수 있다.
- **복합 키(Composite Key)**: **2개 이상**의 속성(attribute)를 사용한 키.
- **후보 키(Candidate key)**: `유일성과 최소성을 만족하는 키`. 기본키가 될 수 있는 후보이기 때문에 후보키라고 불린다. 예를 들면, 주민등록번호, 학번 등
- **기본 키(Primary key)**: `유일성과 최소성을 만족`. 후보 키에서 선택된 키. NULL값이 들어갈 수 없으며, 기본키로 선택된 속성(Attribute)은 동일한 값이 들어갈 수가 없다.
- **대체 키(Surrogate key)**: 후보 키 중에 기본 키로 선택되지 않은 키.
- **외래 키(Foreign Key):** 어떤 테이블(Relation) 간의 기본 키(Primary key)를 참조하는 속성이다. 테이블(Relation)들 간의 관계를 나타내기 위해서 사용된다.
- **자연 키 (Natural Key)** : 중복되는 것을 제외하고 자연스럽게 뽑아 결정하는 기본 키. 언젠가는 변할 수 있는 속성을 가진다.

* **인조 키 (Artificial Key)** : AUTO_INCREAMENT 등 인위적, 인조적으로 유일성은 확보하는 키. 기본키는 보통 인조키로 설정한다.  

  


> - **유일성** : 하나의 키값으로 **튜플을 유일하게 식별**할 수 있는 성질 --> 이 키로 각각의 튜플을 서로 구분할 수 있어야 유일성을 만족한다가 한다. .
> - **최소성** : 키를 구성하는 속성들 중 꼭 필요한 **최소한의 속성**들로만 키를 구성하는 성질 --> 굳이 없어도 될 속성은 넣을 필요 없다.
